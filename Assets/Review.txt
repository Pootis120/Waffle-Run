Начну с того, что понравилось. В отличие от моего подхода, ты не усложняешь то, что усложнять не нужно и по умному используешь те инструменты, которые уже есть в Unity. Не изобретаешь велосипеды.

Ограничение уровня коллайдером, как по мне, идея хорошая. Можно пинать шарик через твердое тело и не заморачиваться. Аналогично и с блокировкой перемещения по осям.

Пару слов про репозиторий.  Вот здесь https://www.toptal.com/developers/gitignore
можно сформировать правильный и подробный файл .gitignore.
Для Unity проекта в репозитории достаточно папок Assets и ProjectSettings. Остальное не нужно.

Дальше пойдут замечания. Они в основном по оформлению кода. Это не догмы, но желательно писать именно так.

0. Строки:
using System.Collections;
using System.Collections.Generic;
Эти пространства имен не используются, поэтому их подключение лучше удалить.

1. Строка: public Vector3 Position;
Переменная Position никак не используется. Можно удалить.

2. Строка: Rigidbody Rb;
Здесь Rb локальная переменная, которая нужна только объекту PlayerMovement. Никто снаружи не должен знать о внутренностях объекта.
И по код-стайлу локальные переменные пишутся с маленькой буквы.
Другой пункт из код-стайла чуть более дискуссионный. Если без подробностей, то поля класса (они же приватные переменные класса) нужно писать с нижнего подчеркивания. Ещё желательно не сокращать названия переменных, давая им осмысленное имя. В теории, эту переменную нужно было назвать _rigidbody. Но по факту наименование _rb для Rigidbody повсеместно встречается. Итого, пишем так:

private Rigidbody _rb;

3. Строка: public float m_Thrust = 20f;
Именование полей, начинающееся с "m_", повсеместно встречается в документации к Unity. Но его не стоит использовать.
Лучше: _thrust
Никакой код извне не должен менять эту переменную. Поэтому private. Её меняет только дизайнер через редактор. Поэтому [SerializeField]. Итого:

[SerializeField] private float _thrust = 20f;

4. Строка: public int health = 150;
Аналогично предыдущему:

[SerializeField] private int _health = 150;

5. Строка: bool onGround = false;
Аналогично предыдущему:

private bool _onGround = false;

6. // Start is called before the first frame update
Такие комментарии нужно удалить

7. Строка void Start()
Изменить на private void Start()

8. Строка: _rb = GetComponent<Rigidbody>();
Здесь нужно сделать одно из. 
Или проверить на null:
Добавить:

if (_rb == null) throw new System.Exception("Не добавлен компонент Rigidbody");

Или примерно то же самое, но заменить строку на:

if(!TryGetComponent(out _rb))
            throw new System.Exception("Не добавлен компонент Rigidbody");

Или (самый правильный вариант) добавить перед названием класса:

[RequireComponent(typeof(Rigidbody))]

9. // Update is called once per frame
Удалить

10. void FixedUpdate() -> private void FixedUpdate()

11. //Apply a force to this Rigidbody in direction of this GameObjects up axis
Комментарий просто пересказывает, что написано в следующей строке. Такие комментарии лучше не писать.

12. Строка: _rb.AddForce(transform.up * _thrust);
Здесь любопытный момент. В данном конкретном случае ошибки нет. Непонятки случатся, если ты случайно изменишь Rotation объекта. В этом случае сила будет толкать объект не вверх, а вдоль его up-вектора. Т.е. под углом. В твоем случае у Rigidbody заблокировано перемещение по x и z, поэтому шарик всё равно будет подниматься вверх, но медленней, чем задумано. Я бы предложил использовать константу Vector3.up:

_rb.AddForce(Vector3.up * _thrust);

В этом случае вектор силы всегда будет направлен вверх, куда бы ни был повернут объект.

13. //More reliable for some reason than OnCollisionStay
Здесь комментарий вполне уместен. А вот ситуация лажовая (( Есть интересное решение. Не знаю, что у него в целом с производительностью, но позволяет не городить огород с кучей проверок. Можно в FixedUpdate проверить, не заснул ли объект:

if (_rb.IsSleeping()) _rb.WakeUp();

Относительно твоего способа есть некоторое незначительное отставание. Но в общем случае это не должно быть критично.

14. Строка: switch(collision.transform.tag) 
Вообще, не рекомендуется использовать строковые литералы. Если такой литерал используется в нескольких местах, то при изменении строки велика вероятность забыть её где-то поменять. Если литерал используется несколько раз внутри класса, то имеет смысл завести константу:

private const string _groundTag = "Ground";

Кстати, Студия подсказывает, что вместо collision.transform.tag лучше использовать:

collision.transform.CompareTag("Ground")

А так как тег - это в принципе строковый литерал, то часто можно встретить рекомендацию вовсе не использовать теги. Альтернативное решение - добавить на объект с коллайдером компонент, а при столкновении проверять наличие этого компонента. Например, так:

if(collision.transform.TryGetComponent(out MyComponent _))
	_health -= 1;
	
В данном случае это всё может быть избыточным, но имей в виду.

15. Строка: switch(collision.transform.tag)
Как я понял, ты заранее предполагаешь вариант, что будет проверка на столкновение с другими препятствиями. Однако, оператор switch тоже рекомендуют применять с осторожностью. В данном случае получилась очень монструозная конструкция. Короче и понятнее написать:

if (collision.transform.CompareTag("Ground"))
	_onGround = true;